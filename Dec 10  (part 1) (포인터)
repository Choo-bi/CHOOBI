** 각 자료형이 차지하는 메모리 공간의 크기

char = 1 byte
short = 2
int = 4
long = 4
float = 4
double = 8

- 포인터를 대상으로 가능한 연산은 덧셈, 뺄셈 뿐.

- 증가(++), 감소(--)

Caution) 
- 포인터를 ++ 연산 시키면 가리키는 대상의 " 메모리 공간 크기 "만큼 값이 증가한다.


포인터 타입         ++ 연산후 증가되는 값 

     char *                        1
    short *                        2
      int *                         4
     long *                        4
     float *                        4
   double *                       8

ex) 증가 연산 예시
========================================================
#include <stdio.h>
int main(void)
{
	char *pc; 
	int *pi;
	double *pd;
 
	pc = (char *)10000;		// 절대주소 라고하며 숫자를 주소로 형변환을 의미.	
	pi = (int *)10000;			
	pd = (double *)10000;			
	printf("증가 전 pc = %d,  pi = %d,  pd = %d\n", pc, pi, pd);
 
	pc++;                 // 각각 1씩 증가
	pi += 1;
	pd = pd + 1;
	printf("증가 후 pc = %d,  pi = %d,  pd = %d\n", pc, pi, pd);
 
	printf("pc+2 = %d,  pi+2 = %d,  pd+2 = %d\n", pc + 2, pi + 2, pd + 2);
 
	return 0;
}
========================================================
  출력값

증가 전 pc = 10000, pi = 10000, pd = 10000
증가 후 pc = 10001, pi = 10004, pd = 10008
pc+2 = 10003, pi+2 = 10012, pd+2 = 10024   <<-- 각각의 메모리 크기만큼 상승한 것을 볼 수 있다.
========================================================
&&&  간접 참조 연산자와 증감 연산자  &&&

 v = *p++   :   p에 *와 ++ 두개의 연산이 적용되며, *,  =, ++ 순서로 연산이 진행. 먼저 p가 가리키는 값
                   을 구해 v에 대입하고 p의 값을 증가.

 v = (*p)++  :  *p 즉 p가 가리키는 변수의 값을 v에 대입한 후, *p즉 p가 가리키는 변수의 값을 증가. 

 v = *++p  :  *(++p)와 같은 의미. p에 대해 ++, * 순으로 진행됨. 이하 생략(위에 연산되로하면 될듯).

 v = ++*p  : ++(*p)를 의미 p에 대해  * , ++ 순으로 연산 진행. 이하 생략.
========================================================

Call-By-Value

함수를 호출할 때는 값으로 인수를 전달하는 것이 C 언어의 기본적인 방법

- 값에 의한 호출
- 인수의 값이 복사되어 복사본이 함수로 전달된다.
==============================================
ex1 )
#include <stdio.h>

void modify(int  value) 
{
	value = 99;		
}

int main(void)
{
	int number = 1;
	
	modify(number);
	printf("number = %d\n", number);

	return 0;
}
  출력값 
number = 1  // 위의 함수형태로는 number의 값을 교체할 수 없다.
==================
ex2 )
 // 변수 2개의 값을 바꾸는 작업을 함수로 작성
#include <stdio.h>

void swap(int x, int y);

int main(void)
{
	int a = 100, b = 200;
	printf(“a=%d  b=%d\n", a, b);

	swap(a,  b);

	printf(“a=%d  b=%d\n", a, b);
	return 0;
}

void swap(int x, int y)
{
	int tmp;          // 지역변수 x, y

	tmp = x;
	x = y;
	y = tmp;
}

  출력값
a=100 b=200
a=100 b=200   // 값이 교환되지않음.
==============================================
##  두 정수를 바꾸기 위한 앞의 함수의 문제점

Call-By-Value 방식으로 호출되어 a의 값 100은 x에 복사되고 b의 값 200은 y에 복사된다.
 함수 swap 에서 x, y의 값이 바뀜
 함수의 실행이 끝난다

!!!!  함수 내의 " 지역변수 x, y "는 함수 실행 종료와 함께 소멸 !!!!

main으로 돌아오면 a, b의 값은 바뀌지 않고 그대로.
--> 호출한 함수 main()에는 아무런 영향을 미치지 못함. 
==============================================

&&  함수의 매개 변수를 포인터로 선언할 수 있다.

1. 함수 정의
void Func(int *p)
{
       printf("%3d", *p);
}
2. 함수 호출
caution)
함수의 매개변수가 포인터 타입이면 함수호출에서 함수에 넘기는 실인자는 변수의 주소이어야 한다

int main()
{
    int b = 99;
    myFunc( &b );
    return 0;
}

출력값 
   99

tip)
****함수의 매개변수를 포인터로 선언하면 호출하는 함수 main과 호출되는 함수가 동일한 메모리를 가리키게됨.

함수의 매개변수가 포인터인 경우 일부에서는 다음과 같은 용어를 사용함.
Call-By-Address
Call-By-Value Pointer
